<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Fabrizio Riguzzi fabrizio.riguzzi@unife.it" />
  <title>cplint Manual</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title"><code>cplint</code> Manual</h1>
<h1 class="subtitle">Yap Version</h1>
<h2 class="author">Fabrizio Riguzzi<br />
fabrizio.riguzzi@unife.it</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#inference">Inference</a><ul>
<li><a href="#commands">Commands</a></li>
<li><a href="#semantic-modules">Semantic Modules</a></li>
<li><a href="#extensions">Extensions</a></li>
<li><a href="#files">Files</a></li>
</ul></li>
<li><a href="#learning">Learning</a><ul>
<li><a href="#input">Input</a></li>
<li><a href="#parameters-1">Parameters</a></li>
<li><a href="#commands-1">Commands</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#learning-examples">Learning Examples</a></li>
</ul></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<h1 id="introduction">Introduction</h1>
<p><code>cplint</code> is a suite of programs for reasoning with ICL <span class="citation">[15]</span>, LPADs <span class="citation">[22,25]</span> and CP-logic programs <span class="citation">[23,24]</span>. It contains programs both for inference and learning.</p>
<p><code>cplint</code> is available in two versions, one for Yap Prolog and one for SWI-Prolog. They differ slightly in the features offered. This manual is about the Yap version. You can find the manual for the SWI-Prolog version at <a href="http://ds.ing.unife.it/~friguzzi/software/cplint-swi/manual.html" class="uri">http://ds.ing.unife.it/~friguzzi/software/cplint-swi/manual.html</a>.</p>
<h1 id="installation">Installation</h1>
<p><code>cplint</code> is distributed in the source code development tree of Yap. It includes Prolog and C files. Download it by following the instruction in <a href="http://www.dcc.fc.up.pt/\string ~vsc/Yap/downloads.html" class="uri">http://www.dcc.fc.up.pt/\string ~vsc/Yap/downloads.html</a>.</p>
<p><code>cplint</code> requires <a href="http://vlsi.colorado.edu/\string ~fabio/CUDD/">CUDD</a>. You can download CUDD from <a href="ftp://vlsi.colorado.edu/pub/cudd-2.5.0.tar.gz" class="uri">ftp://vlsi.colorado.edu/pub/cudd-2.5.0.tar.gz</a>.</p>
<p>Compile CUDD:</p>
<ol>
<li><p>decompress cudd-2.4.2.tar.gz</p></li>
<li><p><code>cd cudd-2.4.2</code></p></li>
<li><p>see the <code>README</code> file for instructions on compilation</p></li>
</ol>
<p>Install Yap together with <code>cplint</code>: when compiling Yap following the instruction of the <code>INSTALL</code> file in the root of the Yap folder, use</p>
<pre><code>configure --enable-cplint=DIR</code></pre>
<p>where <code>DIR</code> is the directory where CUDD is, i.e., the directory ending with <code>cudd-2.5.0</code>. Under Windows, you have to use Cygwin (CUDD does not compile under MinGW), so<br />
</p>
<pre><code>configure --enable-cplint=DIR --enable-cygwin</code></pre>
<p>After having performed <code>make install</code> you can do <code>make installcheck</code> that will execute a suite of tests of the various programs. If no error is reported you have a working installation of <code>cplint</code>.</p>
<h1 id="syntax">Syntax</h1>
<p>LPAD and CP-logic programs consist of a set of annotated disjunctive clauses. Disjunction in the head is represented with a semicolon and atoms in the head are separated from probabilities by a colon. For the rest, the usual syntax of Prolog is used. For example, the CP-logic clause <br /><span class="math display"><em>h</em><sub>1</sub> : <em>p</em><sub>1</sub> ∨ … ∨ <em>h</em><sub><em>n</em></sub> : <em>p</em><sub><em>n</em></sub> ← <em>b</em><sub>1</sub>, …, <em>b</em><sub><em>m</em></sub>, ¬<em>c</em><sub>1</sub>, …, ¬<em>c</em><sub><em>l</em></sub></span><br /> is represented by</p>
<pre><code>h1:p1 ; ... ; hn:pn :- b1,...,bm,\+ c1,....,\+ cl</code></pre>
<p>No parentheses are necessary. The <code>pi</code> are numeric expressions. It is up to the user to ensure that the numeric expressions are legal, i.e. that they sum up to less than one.</p>
<p>If the clause has an empty body, it can be represented like this</p>
<pre><code>h1:p1 ; ... ;hn:pn.</code></pre>
<p>If the clause has a single head with probability 1, the annotation can be omitted and the clause takes the form of a normal prolog clause, i.e.</p>
<pre><code>h1:- b1,...,bm,\+ c1,...,\+ cl.</code></pre>
<p>stands for</p>
<pre><code>h1:1 :- b1,...,bm,\+ c1,...,\+ cl.</code></pre>
<p>The coin example of <span class="citation">[25]</span> is represented as (see file <code>coin.cpl</code>)</p>
<pre><code>heads(Coin):1/2 ; tails(Coin):1/2:- 
     toss(Coin),\+biased(Coin).

heads(Coin):0.6 ; tails(Coin):0.4:- 
     toss(Coin),biased(Coin).

fair(Coin):0.9 ; biased(Coin):0.1.

toss(coin).</code></pre>
<p>The first clause states that if we toss a coin that is not biased it has equal probability of landing heads and tails. The second states that if the coin is biased it has a slightly higher probability of landing heads. The third states that the coin is fair with probability 0.9 and biased with probability 0.1 and the last clause states that we toss a coin with certainty.</p>
<p>Moreover, the bodies of rules can contain the built-in predicates:</p>
<pre><code>is/2, &gt;/2, &lt;/2, &gt;=/2 ,=&lt;/2,
=:=/2, =\=/2, true/0, false/0,
=/2, ==/2, \=/2 ,\==/2, length/2</code></pre>
<p>The bodies can also contain the following library predicates:</p>
<pre><code>member/2, max_list/2, min_list/2
nth0/3, nth/3</code></pre>
<p>plus the predicate</p>
<pre><code>average/2</code></pre>
<p>that, given a list of numbers, computes its arithmetic mean.</p>
<p>The syntax of ICL program is the one used by the <a href="http://www.cs.ubc.ca/\string ~poole/aibook/code/ailog/ailog2.html">AILog 2</a> system.</p>
<h1 id="inference">Inference</h1>
<p><code>cplint</code> contains various modules for answering queries.</p>
<p>These modules answer queries using using goal-oriented procedures:</p>
<ul>
<li><p><code>lpadsld.pl</code>: uses the top-down procedure described in in <span class="citation">[17]</span> and <span class="citation">[18]</span>. It is based on SLDNF resolution and is an adaptation of the interpreter for ProbLog <span class="citation">[11]</span>.</p>
<p>It was proved correct <span class="citation">[18]</span> with respect to the semantics of LPADs for range restricted acyclic programs <span class="citation">[1]</span> without function symbols.</p>
<p>It is also able to deal with extensions of LPADs and CP-logic: the clause bodies can contain <code>setof</code> and <code>bagof</code>, the probabilities in the head may be depend on variables in the body and it is possible to specify a uniform distribution in the head with reference to a <code>setof</code> or <code>bagof</code> operator. These extended features have been introduced in order to represent CLP(BN) <span class="citation">[21]</span> programs and PRM models <span class="citation">[14]</span>: <code>setof</code> and <code>bagof</code> allow to express dependency of an attribute from an aggregate function of another attribute, as in CLP(BN) and PRM, while the possibility of specifying a uniform distribution allows the use of the reference uncertainty feature of PRM.</p></li>
<li><p><code>picl.pl</code>: performs inference on ICL programs <span class="citation">[19]</span></p></li>
<li><p><code>lpad.pl</code>: uses a top-down procedure based on SLG resolution <span class="citation">[9]</span>. As a consequence, it works for any sound LPADs, i.e., any LPAD such that each of its instances has a two valued well founded model.</p></li>
<li><p><code>cpl.pl</code>: uses a top-down procedure based on SLG resolution and moreover checks that the CP-logic program is valid, i.e., that it has at least an execution model.</p></li>
<li><p>Modules for approximate inference:</p>
<ul>
<li><p><code>deepit.pl</code> performs iterative deepening <span class="citation">[8]</span></p></li>
<li><p><code>deepdyn.pl</code> performs dynamic iterative deepening <span class="citation">[8]</span></p></li>
<li><p><code>bestk.pl</code> performs k-Best <span class="citation">[8]</span></p></li>
<li><p><code>bestfirst.pl</code> performs best first <span class="citation">[8]</span></p></li>
<li><p><code>montecarlo.pl</code> performs Monte Carlo <span class="citation">[8]</span></p></li>
<li><p><code>mcintyre.pl</code>: implements the algorithm MCINTYRE (Monte Carlo INference wiTh Yap REcord) <span class="citation">[20]</span></p></li>
</ul></li>
<li><p><code>approx/exact.pl</code> as <code>lpadsld.pl</code> but uses SimplecuddLPADs, a modification of the <a href="http://dtai.cs.kuleuven.be/problog/download.html">Simplecudd</a> instead of the <code>cplint</code> library for building BDDs and computing the probability.</p></li>
</ul>
<p>These modules answer queries using the definition of the semantics of LPADs and CP-logic:</p>
<ul>
<li><p><code>semlpadsld.pl</code>: given an LPAD <span class="math inline"><em>P</em></span>, it generates all the instances of <span class="math inline"><em>P</em></span>. The probability of a query <span class="math inline"><em>Q</em></span> is computed by identifying all the instances where <span class="math inline"><em>Q</em></span> is derivable by SLDNF resolution.</p></li>
<li><p><code>semlpad.pl</code>: given an LPAD <span class="math inline"><em>P</em></span>, it generates all the instances of <span class="math inline"><em>P</em></span>. The probability of a query <span class="math inline"><em>Q</em></span> is computed by identifying all the instances where <span class="math inline"><em>Q</em></span> is derivable by SLG resolution.</p></li>
<li><p><code>semlcpl.pl</code>: given an LPAD <span class="math inline"><em>P</em></span>, it builds an execution model of <span class="math inline"><em>P</em></span>, i.e., a probabilistic process that satisfy the principles of universal causation, sufficient causation, independent causation, no deus ex machina events and temporal precedence. It uses the definition of the semantics given in <span class="citation">[24]</span>.</p></li>
</ul>
<h2 id="commands">Commands</h2>
<p>The LPAD or CP-logic program must be stored in a text file with extension <code>.cpl</code>. Suppose you have stored the example above in file <code>coin.cpl</code>. In order to answer queries from this program, you have to run Yap, load one of the modules (such as for example <code>lpad.pl</code>) by issuing the command</p>
<pre><code>use_module(library(lpad)).</code></pre>
<p>at the command prompt. Then you must parse the source file <code>coin.cpl</code> with the command</p>
<pre><code>p(coin).</code></pre>
<p>if <code>coin.cpl</code> is in the current directory, or</p>
<pre><code>p(&#39;path_to_coin/coin&#39;).</code></pre>
<p>if <code>coin.cpl</code> is in a different directory. At this point you can pose query to the program by using the predicate <code>s/2</code> (for solve) that takes as its first argument a conjunction of goals in the form of a list and returns the computed probability as its second argument. For example, the probability of the conjunction <code>head(coin),biased(coin)</code> can be asked with the query</p>
<pre><code>s([head(coin),biased(coin)],P).</code></pre>
<p>For computing the probability of a conjunction given another conjunction you can use the predicate <code>sc/3</code> (for solve conditional) that take takes as input the query conjunction as its first argument, the evidence conjunction as its second argument and returns the probability in its third argument. For example, the probability of the query <code>heads(coin)</code> given the evidence <code>biased(coin)</code> can be asked with the query</p>
<pre><code>sc([heads(coin)],[biased(coin)],P).</code></pre>
<p>After having parsed a program, in order to read in a new program you must restart Yap when using <code>semlpadsld.pl</code> and <code>semlpad.pl</code>. With the other modules, you can directly parse a new program.</p>
<p>When using <code>lpad.pl</code>, the system can print the message “Uunsound program” in the case in which an instance with a three valued well founded model is found. Moreover, it can print the message “It requires the choice of a head atom from a non ground head”: in this case, in order to answer the query, all the groundings of the culprit clause must be generated, which may be impossible for programs with function symbols.</p>
<p>When using <code>semcpl.pl</code>, you can print the execution process by using the command <code>print.</code> after <code>p(file).</code> Moreover, you can build an execution process given a context by issuing the command <code>parse(file)</code>. and then <code>build(context).</code> where <code>context</code> is a list of atoms that are true in the context. <code>semcpl.pl</code> can print “Invalid program” in the case in which no execution process exists.</p>
<p>When using <code>cpl.pl</code> you can print a partial execution model including all the clauses involved in the query issued with <code>print.</code> <code>cpl.pl</code> can print the messages “Uunsound program”, “It requires the choice of a head atom from a non ground head” and “Invalid program”.</p>
<p>For <code>approx/deepit.pl</code> and <code>approx/deepdyn.pl</code> the command</p>
<pre><code>solve(GoalsList, ProbLow, ProbUp, ResTime, BddTime)</code></pre>
<p>takes as input a list of goals <code>GoalsList</code> and returns a lower bound on the probability <code>ProbLow</code>, an upper bound on the probability <code>ProbUp</code>, the CPU time spent on performing resolution <code>ResTime</code> and the CPU time spent on handling BDDs <code>BddTime</code>.</p>
<p>For <code>approx/bestk.pl</code> the command</p>
<pre><code>solve(GoalsList, ProbLow,  ResTime, BddTime)</code></pre>
<p>takes as input a list of goals <code>GoalsList</code> and returns a lower bound on the probability <code>ProbLow</code>, the CPU time spent on performing resolution <code>ResTime</code> and the CPU time spent on handling BDDs <code>BddTime</code>.</p>
<p>For <code>approx/bestfirst.pl</code> the command</p>
<pre><code>solve(GoalsList, ProbLow, ProbUp, Count, ResTime, BddTime)</code></pre>
<p>takes as input a list of goals <code>GoalsList</code> and returns a lower bound on the probability <code>ProbLow</code>, an upper bound on the probability <code>ProbUp</code>, the number of BDDs generated by the algorithm <code>Count</code>, the CPU time spent on performing resolution <code>ResTime</code> and the CPU time spent on handling BDDs <code>BddTime</code>.</p>
<p>For <code>approx/montecarlo.pl</code> the command</p>
<pre><code>solve(GoalsList, Samples, Time, Low, Prob, Up)</code></pre>
<p>takes as input a list of goals <code>GoalsList</code> and returns the number of samples taken <code>Samples</code>, the time required to solve the problem <code>Time</code>, the lower end of the confidence interval <code>Lower</code>, the estimated probability <code>Prob</code> and the upper end of the confidence interval <code>Up</code>.</p>
<p>For <code>mcintyre.pl</code>: the command</p>
<pre><code>solve(Goals, Samples, CPUTime, WallTime, Lower, Prob, Upper) :-</code></pre>
<p>takes as input a conjunction of goals <code>Goals</code> and returns the number of samples taken <code>Samples</code>, the CPU time required to solve the problem <code>CPUTime</code>, the wall time required to solve the problem <code>CPUTime</code>, the lower end of the confidence interval <code>Lower</code>, the estimated probability <code>Prob</code> and the upper end of the confidence interval <code>Up</code>.</p>
<p>For <code>approx/exact.pl</code> the command</p>
<pre><code>solve(GoalsList, Prob, ResTime, BddTime) </code></pre>
<p>takes as input a conjunction of goals <code>Goals</code> and returns the probability <code>Prob</code>, the CPU time spent on performing resolution <code>ResTime</code> and the CPU time spent on handling BDDs <code>BddTime</code>.</p>
<h3 id="parameters">Parameters</h3>
<p>The modules make use of a number of parameters in order to control their behavior. They that can be set with the command</p>
<pre><code>set(parameter,value).</code></pre>
<p>from the Yap prompt after having loaded the module. The current value can be read with</p>
<pre><code>setting(parameter,Value).</code></pre>
<p>from the Yap prompt. The available parameters are:</p>
<ul>
<li><p><code>epsilon_parsing</code> (valid for all modules): if (1 - the sum of the probabilities of all the head atoms) is smaller than <code>epsilon_parsing</code> then <code>cplint</code> adds the null events to the head. Default value 0.00001</p></li>
<li><p><code>save_dot</code> (valid for all goal-oriented modules): if <code>true</code> a graph representing the BDD is saved in the file <code>cpl.dot</code> in the current directory in dot format. The variables names are of the form <code>Xn_m</code> where <code>n</code> is the number of the multivalued variable and <code>m</code> is the number of the binary variable. The correspondence between variables and clauses can be evinced from the message printed on the screen, such as</p>
<pre><code>Variables: [(2,[X=2,X1=1]),(2,[X=1,X1=0]),(1,[])]</code></pre>
<p>where the first element of each couple is the clause number of the input file (starting from 1). In the example above variable <code>X0</code> corresponds to clause <code>2</code> with the substitutions <code>X=2,X1=1</code>, variable <code>X1</code> corresponds to clause <code>2</code> with the substitutions <code>X=1,X1=0</code> and variable <code>X2</code> corresponds to clause <code>1</code> with the empty substitution. You can view the graph with <a href="http://www.graphviz.org"><code>graphviz</code></a> using the command</p>
<pre><code>dotty cpl.dot &amp;</code></pre></li>
<li><p><code>ground_body</code>: (valid for <code>lpadsld.pl</code> and all semantic modules) determines how non ground clauses are treated: if <code>true</code>, ground clauses are obtained from a non ground clause by replacing each variable with a constant, if <code>false</code>, ground clauses are obtained by replacing only variables in the head with a constant. In the case where the body contains variables not in the head, setting it to false means that the body represents an existential event.</p></li>
<li><p><code>min_error</code>: (valid for <code>approx/deepit.pl</code>, <code>approx/deepdyn.pl</code>, <code>approx/bestk.pl</code>, <code>approx/bestfirst.pl</code>, <code>approx/montecarlo.pl</code> and <code>mcintyre.pl</code>) is the threshold under which the difference between upper and lower bounds on probability must fall for the algorithm to stop.</p></li>
<li><p><code>k</code>: maximum number of explanations for <code>approx/bestk.pl</code> and <code>approx/bestfirst.pl</code> and number of samples to take at each iteration for <code>approx/montecarlo.pl</code> and <code>mcintyre.pl</code></p></li>
<li><p><code>prob_bound</code>: (valid for <code>approx/deepit.pl</code>, <code>approx/deepdyn.pl</code>, <code>approx/bestk.pl</code> and <code>approx/bestfirst.pl</code>) is the initial bound on the probability of explanations when iteratively building explanations</p></li>
<li><p><code>prob_step</code>: (valid for <code>approx/deepit.pl</code>, <code>approx/deepdyn.pl</code>, <code>approx/bestk.pl</code> and <code>approx/bestfirst.pl</code>) is the increment on the bound on the probability of explanations when iteratively building explanations</p></li>
<li><p><code>timeout</code>: (valid for <code>approx/deepit.pl</code>, <code>approx/deepdyn.pl</code>, <code>approx/bestk.pl</code>, <code>approx/bestfirst.pl</code> and <code>approx/exact.pl</code>) timeout for builduing BDDs</p></li>
</ul>
<h2 id="semantic-modules">Semantic Modules</h2>
<p>The three semantic modules need to produce a grounding of the program in order to compute the semantics. They require an extra file with extension <code>.uni</code> (for universe) in the same directory where the <code>.cpl</code> file is.</p>
<p>There are two ways to specify how to ground a program. The first consists in providing the list of constants to which each variable can be instantiated. For example, in our case the current directory will contain a file <code>coin.uni</code> that is a Prolog file containing facts of the form</p>
<pre><code>universe(var_list,const_list).</code></pre>
<p>where <code>var_list</code> is a list of variables names (each must be included in single quotes) and <code>const_list</code> is a list of constants. The semantic modules generate the grounding by instantiating in all possible ways the variables of <code>var_list</code> with the constants of <code>const_list</code>. Note that the variables are identified by name, so a variable with the same name in two different clauses will be instantiated with the same constants.</p>
<p>The other way to specify how to ground a program consists in using mode and type information. For each predicate, the file <code>.uni</code> must contain a fact of the form</p>
<pre><code>mode(predicate(t1,...,tn)).</code></pre>
<p>that specifies the number and types of each argument of the predicate. Then, the list of constants that are in the domain of each type <code>ti</code> must be specified with a fact of the form</p>
<pre><code>type(ti,list_of_constants).</code></pre>
<p>The file <code>.uni</code> can contain both universe and mode declaration, the ones to be used depend on the value of the parameter <code>grounding</code>: with value <code>variables</code>, the universe declarations are used, with value <code>modes</code> the mode declarations are used.</p>
<p>With <code>semcpl.pl</code> only mode declarations can be used.</p>
<h2 id="extensions">Extensions</h2>
<p>In this section we will present the extensions to the syntax of LPADs and CP-logic programs that <code>lpadsld</code> can handle.</p>
<p>When using <code>lpadsld.pl</code>, the bodies can contain the predicates <code>setof/3</code> and <code>bagof/3</code> with the same meaning as in Prolog. Existential quantifiers are allowed in both, so for example the query</p>
<pre><code>setof(Z, (term(X,Y))^foo(X,Y,Z), L).</code></pre>
<p>returns all the instantiations of <code>Z</code> such that there exists an instantiation of <code>X</code> and <code>Y</code> for which <code>foo(X,Y,Z)</code> is true.</p>
<p>An example of the use of <code>setof</code> and <code>bagof</code> is in the file <code>female.cpl</code>:</p>
<pre><code>male(C):M/P ; female(C):F/P:-
    person(C),
    setof(Male,known_male(Male),LM),
    length(LM,M),
    setof(Female,known_female(Female),LF),
    length(LF,F),
    P is F+M.

person(f).

known_female(a).
known_female(b).
known_female(c).
known_male(d).
known_male(e).</code></pre>
<p>The disjunctive rule expresses the probability of a person of unknown sex of being male or female depending on the number of males and females that are known. This is an example of the use of expressions in the probabilities in the head that depend on variables in the body. The probabilities are well defined because they always sum to 1 (unless <code>P</code> is 0).</p>
<p>Another use of <code>setof</code> and <code>bagof</code> is to have an attribute depend on an aggregate function of another attribute, similarly to what is done in PRM and CLP(BN).</p>
<p>So, in the classical school example (available in <code>student.cpl</code>) you can find the following clauses:</p>
<pre><code>student_rank(S,h):0.6 ; student_rank(S,l):0.4:- 
    bagof(G,R^(registr_stu(R,S),registr_gr(R,G)),L),
    average(L,Av),Av&gt;1.5.

student_rank(S,h):0.4 ; student_rank(S,l):0.6:- 
    bagof(G,R^(registr_stu(R,S),registr_gr(R,G)),L),
    average(L,Av),Av =&lt; 1.5.</code></pre>
<p>where <code>registr_stu(R,S)</code> expresses that registration <code>R</code> refers to student <code>S</code> and <code>registr_gr(R,G)</code> expresses that registration <code>R</code> reports grade <code>G</code> which is a natural number. The two clauses express a dependency of the rank of the student from the average of her grades.</p>
<p>Another extension can be used with <code>lpadsld.pl</code> in order to be able to represent reference uncertainty of PRMs. Reference uncertainty means that the link structure of a relational model is not fixed but is uncertain: this is represented by having the instance referenced in a relationship be chosen uniformly from a set. For example, consider a domain modeling scientific papers: you have a single entity, paper, and a relationship, cites, between paper and itself that connects the citing paper to the cited paper. To represent the fact that the cited paper and the citing paper are selected uniformly from certain sets, the following clauses can be used (see file <code>paper_ref_simple.cpl</code>):</p>
<pre><code>uniform(cites_cited(C,P),P,L):-
    bagof(Pap,paper_topic(Pap,theory),L).

uniform(cites_citing(C,P),P,L):-
    bagof(Pap,paper_topic(Pap,ai),L).</code></pre>
<p>The first clauses states that the paper <code>P</code> cited in a citation <code>C</code> is selected uniformly from the set of all papers with topic theory. The second clauses expresses that the citing paper is selected uniformly from the papers with topic ai.</p>
<p>These clauses make use of the predicate</p>
<pre><code>uniform(Atom,Variable,List)</code></pre>
<p>in the head, where <code>Atom</code> must contain <code>Variable</code>. The meaning is the following: the set of all the atoms obtained by instantiating <code>Variable</code> of <code>Atom</code> with a term taken from <code>List</code> is generated and the head is obtained by having a disjunct for each instantiation with probability <span class="math inline">1/<em>N</em></span> where <span class="math inline"><em>N</em></span> is the length of <code>List</code>.</p>
<p>A more elaborate example is present in file <code>paper_ref.cpl</code>:</p>
<pre><code>uniform(cites_citing(C,P),P,L):-
    setof(Pap,paper(Pap),L).

cites_cited_group(C,theory):0.9 ; cites_cited_group(C,ai):0.1:-
    cites_citing(C,P),paper_topic(P,theory).

cites_cited_group(C,theory):0.01;cites_cited_group(C,ai):0.99:-
    cites_citing(C,P),paper_topic(P,ai).

uniform(cites_cited(C,P),P,L):-
    cites_cited_group(C,T),bagof(Pap,paper_topic(Pap,T),L).</code></pre>
<p>where the cited paper depends on the topic of the citing paper. In particular, if the topic is theory, the cited paper is selected uniformly from the papers about theory with probability 0.9 and from the papers about ai with probability 0.1. if the topic is ai, the cited paper is selected uniformly from the papers about theory with probability 0.01 and from the papers about ai with probability 0.99.</p>
<p>PRMs take into account as well existence uncertainty, where the existence of instances is also probabilistic. For example, in the paper domain, the total number of citations may be unknown and a citation between any two paper may have a probability of existing. For example, a citation between two paper may be more probable if they are about the same topic:</p>
<pre><code>cites(X,Y):0.005 :- 
    paper_topic(X,theory),paper_topic(Y,theory).

cites(X,Y):0.001 :- 
    paper_topic(X,theory),paper_topic(Y,ai).

cites(X,Y):0.003 :- 
    paper_topic(X,ai),paper_topic(Y,theory).

cites(X,Y):0.008 :- 
    paper_topic(X,ai),paper_topic(Y,ai).</code></pre>
<p>This is an example where the probabilities in the head do not sum up to one so the null event is automatically added to the head. The first clause states that, if the topic of a paper <code>X</code> is theory and of paper <code>Y</code> is theory, there is a probability of 0.005 that there is a citation from <code>X</code> to <code>Y</code>. The other clauses consider the remaining cases for the topics.</p>
<h2 id="files">Files</h2>
<p>In the directory where Yap keeps the library files (usually <code>/usr/local/share/ Yap</code>) you can find the directory <code>cplint</code> that contains the files:</p>
<ul>
<li><p><code>testlpadsld_gbtrue.pl, testlpadsld_gbfalse.pl, testlpad.pl, testcpl.pl, testsemlpadsld.pl, testsemlpad.pl testsemcpl.pl</code>: Prolog programs for testing the modules. They are executed when issuing the command <code>make installcheck</code> during the installation. To execute them afterwords, load the file and issue the command <code>t.</code></p></li>
<li><p>Subdirectory <code>examples</code>:</p>
<ul>
<li><p><code>alarm.cpl</code>: representation of the Bayesian network in Figure 2 of <span class="citation">[25]</span>.</p></li>
<li><p><code>coin.cpl</code>: coin example from <span class="citation">[25]</span>.</p></li>
<li><p><code>coin2.cpl</code>: coin example with two coins.</p></li>
<li><p><code>dice.cpl</code>: dice example from <span class="citation">[25]</span>.</p></li>
<li><p><code>twosideddice.cpl, threesideddice.cpl</code> game with idealized dice with two or three sides. Used in the experiments in <span class="citation">[18]</span>.</p></li>
<li><p><code>ex.cpl</code>: first example in <span class="citation">[18]</span>.</p></li>
<li><p><code>exapprox.cpl</code>: example showing the problems of approximate inference (see <span class="citation">[18]</span>).</p></li>
<li><p><code>exrange.cpl</code>: example showing the problems with non range restricted programs (see <span class="citation">[18]</span>).</p></li>
<li><p><code>female.cpl</code>: example showing the dependence of probabilities in the head from variables in the body (from <span class="citation">[25]</span>).</p></li>
<li><p><code>mendel.cpl, mendels.cpl</code>: programs describing the Mendelian rules of inheritance, taken from <span class="citation">[7]</span>.</p></li>
<li><p><code>paper_ref.cpl, paper_ref_simple.cpl</code>: paper citations examples, showing reference uncertainty, inspired by <span class="citation">[14]</span>.</p></li>
<li><p><code>paper_ref_not.cpl</code>: paper citations example showing that negation can be used also for predicates defined by clauses with <code>uniform</code> in the head.</p></li>
<li><p><code>school.cpl</code>: example inspired by the example <code>school_32.yap</code> from the source distribution of Yap in the <code>CLPBN</code> directory.</p></li>
<li><p><code>school_simple.cpl</code>: simplified version of <code>school.cpl</code>.</p></li>
<li><p><code>student.cpl</code>: student example from Figure 1.3 of <span class="citation">[13]</span>.</p></li>
<li><p><code>win.cpl, light.cpl, trigger.cpl, throws.cpl, hiv.cpl,</code><br />
<code> invalid.cpl</code>: programs taken from <span class="citation">[24]</span>. <code>invalid.cpl</code> is an example of a program that is invalid but sound.</p></li>
</ul>
<p>The files <code>*.uni</code> that are present for some of the examples are used by the semantical modules. Some of the example files contain in an initial comment some queries together with their result.</p></li>
<li><p>Subdirectory <code>doc</code>: contains this manual in latex, html and pdf.</p></li>
</ul>
<h1 id="learning">Learning</h1>
<p><code>cplint</code> contains the following learning algorithms:</p>
<ul>
<li><p>CEM (<code>cplint</code> EM): an implementation of EM for learning parameters that is based on <code>lpadsld.pl</code> <span class="citation">[16]</span></p></li>
<li><p>RIB (Relational Information Bottleneck): an algorithm for learning parameters based on the Information Bottleneck <span class="citation">[16]</span></p></li>
<li><p>EMBLEM (EM over Bdds for probabilistic Logic programs Efficient Mining): an implementation of EM for learning parameters that computes expectations directly on BDDs <span class="citation">[2,3,5]</span></p></li>
<li><p>SLIPCASE (Structure LearnIng of ProbabilistiC logic progrAmS with Em over bdds): an algorithm for learning the structure of programs by searching directly the theory space <span class="citation">[4]</span></p></li>
<li><p>SLIPCOVER (Structure LearnIng of Probabilistic logic programs by searChing OVER the clause space): an algorithm for learning the structure of programs by searching the clause space and the theory space separatery <span class="citation">[6]</span></p></li>
<li><p>LEMUR (LEarning with a Monte carlo Upgrade of tRee search): an algorithm for learning the structure of programs by searching the clase space using Monte-Carlo tree search.</p></li>
</ul>
<h2 id="input">Input</h2>
<p>To execute the learning algorithms, prepare four files in the same folder:</p>
<ul>
<li><p><code>&lt;stem&gt;.kb</code>: contains the example interpretations</p></li>
<li><p><code>&lt;stem&gt;.bg</code>: contains the background knowledge, i.e., knowledge valid for all interpretations</p></li>
<li><p><code>&lt;stem&gt;.l</code>: contains language bias information</p></li>
<li><p><code>&lt;stem&gt;.cpl</code>: contains the LPAD for you which you want to learn the parameters or the initial LPAD for SLIPCASE and LEMUR. For SLIPCOVER, this file should be absent</p></li>
</ul>
<p>where <code>&lt;stem&gt;</code> is your dataset name. Examples of these files can be found in the dataset pages.</p>
<p>In <code>&lt;stem&gt;.kb</code> the example interpretations have to be given as a list of Prolog facts initiated by <code>begin(model(&lt;name&gt;)).</code> and terminated by <code>end(model(&lt;name&gt;)).</code> as in</p>
<pre><code>begin(model(b1)).
sameperson(1,2).
movie(f1,1).
movie(f1,2).
workedunder(1,w1).
workedunder(2,w1).
gender(1,female).
gender(2,female).
actor(1).
actor(2).
end(model(b1)).</code></pre>
<p>The interpretations may contain a fact of the form</p>
<pre><code>prob(0.3).</code></pre>
<p>assigning a probability (0.3 in this case) to the interpretations. If this is omitted, the probability of each interpretation is considered equal to <span class="math inline">1/<em>n</em></span> where <span class="math inline"><em>n</em></span> is the total number of interpretations. <code>prob/1</code> can be used to set different multiplicity for the different interpretations.</p>
<p>In order for RIB to work, the input interpretations must share the Herbrand universe. If this is not the case, you have to translate the interpretations in this was, see for example the <code>sp1</code> files in RIB’s folder, that are the results of the conversion of the first fold of the IMDB dataset.</p>
<p><code>&lt;stem&gt;.bg</code> can contain Prolog clauses that can be used to derive additional conclusions from the atoms in the interpretations.</p>
<p><code>&lt;stem&gt;.l</code> contains the declarations of the input and output predicates, of the unseen predicates and the commands for setting the algorithms’ parameters. Output predicates are declared as</p>
<pre><code>output(&lt;predicate&gt;/&lt;arity&gt;).</code></pre>
<p>and define the predicates whose atoms in the input interpretations are used as the goals for the prediction of which you want to optimize the parameters. Derivations for these goals are built by the systems.</p>
<p>Input predicates are those for the predictions of which you do not want to optimize the parameters. You can declare closed world input predicates with</p>
<pre><code>input_cw(&lt;predicate&gt;/&lt;arity&gt;).</code></pre>
<p>For these predicates, the only true atoms are those in the interpretations, the clauses in the input program are not used to derive atoms not present in the interpretations.</p>
<p>Open world input predicates are declared with</p>
<pre><code>input(&lt;predicate&gt;/&lt;arity&gt;).</code></pre>
<p>In this case, if a subgoal for such a predicate is encountered when deriving the atoms for the output predicates, both the facts in the interpretations and the clauses of the input program are used.</p>
<p>For RIB, if there are unseen predicates, i.e., predicates that are present in the input program but not in the interpretations, you have to declare them with</p>
<pre><code>unseen(&lt;predicate&gt;/&lt;arity&gt;).</code></pre>
<p>For SLIPCASE, SLIPCOVER and LEMUR, you have to specify the language bias by means of mode declarations in the style of <a href="http://www.doc.ic.ac.uk/\string ~shm/progol.html">Progol</a>.</p>
<pre><code>modeh(&lt;recall&gt;,&lt;predicate&gt;(&lt;arg1&gt;,...).</code></pre>
<p>specifies the atoms that can appear in the head of clauses, while</p>
<pre><code>modeb(&lt;recall&gt;,&lt;predicate&gt;(&lt;arg1&gt;,...).</code></pre>
<p>specifies the atoms that can appear in the body of clauses. <code>&lt;recall&gt;</code> can be an integer or <code>*</code> (currently unused).</p>
<p>The arguments are of the form</p>
<pre><code>+&lt;type&gt;</code></pre>
<p>for specifying an input variable of type <code>&lt;type&gt;</code>, or</p>
<pre><code>-&lt;type&gt;</code></pre>
<p>for specifying an output variable of type <code>&lt;type&gt;</code>. or</p>
<pre><code>&lt;constant&gt;</code></pre>
<p>for specifying a constant.</p>
<p>SLIPCOVER also allows the arguments</p>
<pre><code>#&lt;type&gt;</code></pre>
<p>for specifying an argument which should be replaced by a constant of type <code>&lt;type&gt;</code> in the bottom clause but should not be used for replacing input variables of the following literals or</p>
<pre><code>-#&lt;type&gt;</code></pre>
<p>for specifying an argument which should be replaced by a constant of type <code>&lt;type&gt;</code> in the bottom clause and that should be used for replacing input variables of the following literals. <code>#</code> and <code>-#</code> differ only in the creation of the bottom clause.</p>
<p>An example of language bias for the UWCSE domain is</p>
<pre><code>output(advisedby/2).

input(student/1).
input(professor/1).
....

modeh(*,advisedby(+person,+person)). 

modeb(*,professor(+person)).
modeb(*,student(+person)).
modeb(*,sameperson(+person, -person)). 
modeb(*,sameperson(-person, +person)). 
modeb(*,samecourse(+course, -course)). 
modeb(*,samecourse(-course, +course)). 
....</code></pre>
<p>SLIPCOVER and LEMUR lso requires facts for the <code>determination/2</code> predicate that indicate which predicates can appear in the body of clauses. For example</p>
<pre><code>determination(professor/1,student/1).
determination(student/1,hasposition/2).</code></pre>
<p>state that <code>student/1</code> can appear in the body of clauses for <code>professor/1</code> and that <code>hasposition/2</code> can appear in the body of clauses for <code>student/1</code>.</p>
<p>SLIPCOVER also allows mode declarations of the form</p>
<pre><code>modeh(&lt;r&gt;,[&lt;s1&gt;,...,&lt;sn&gt;],[&lt;a1&gt;,...,&lt;an&gt;],[&lt;P1/Ar1&gt;,...,&lt;Pk/Ark&gt;]). </code></pre>
<p>These mode declarations are used to generate clauses with more than two head atoms. In them, <code>&lt;s1&gt;,...,&lt;sn&gt;</code> are schemas, <code>&lt;a1&gt;,...,&lt;an&gt;</code> are atoms such that <code>&lt;ai&gt;</code> is obtained from <span class="math inline">$\verb|&lt;si&gt;|$</span> by replacing placemarkers with variables, <code>&lt;Pi/Ari&gt;</code> are the predicates admitted in the body. <code>&lt;a1&gt;,...,&lt;an&gt;</code> are used to indicate which variables should be shared by the atoms in the head. An example of such a mode declaration is</p>
<pre><code>modeh(*,
  [advisedby(+person,+person),tempadvisedby(+person,+person)],
  [advisedby(A,B),tempadvisedby(A,B)],
  [professor/1,student/1,hasposition/2,inphase/2,
      publication/2,taughtby/3,ta/3,courselevel/2,yearsinprogram/2]).</code></pre>
<h2 id="parameters-1">Parameters</h2>
<p>In order to set the algorithms’ parameters, you have to insert in <code>&lt;stem&gt;.l</code> commands of the form</p>
<pre><code>:- set(&lt;parameter&gt;,&lt;value&gt;).</code></pre>
<p>The available parameters are:</p>
<ul>
<li><p><code>depth</code> (values: integer or <code>inf</code>, default value: 3): depth of derivations if <code>depth_bound</code> is set to <code>true</code></p></li>
<li><p><code>single_var</code> (values: <code>{true,false}</code>, default value: <code>false</code>, valid for CEM, EMBLEM, SLIPCASE, SLIPCOVER and LEMUR): if set to <code>true</code>, there is a random variable for each clauses, instead of a separate random variable for each grounding of a clause</p></li>
<li><p><code>sample_size</code> (values: integer, default value: 1000): total number of examples in case in which the models in the <code>.kb</code> file contain a <code>prob(P).</code> fact. In that case, one model corresponds to <code>sample_size*P</code> examples</p></li>
<li><p><code>epsilon_em</code> (values: real, default value: 0.1, valid for CEM, EMBLEM, SLIPCASE, SLIPCOVER and LEMUR): if the difference in the log likelihood in two successive EM iteration is smaller than <code>epsilon_em</code>, then EM stops</p></li>
<li><p><code>epsilon_em_fraction</code> (values: real, default value: 0.01, valid for CEM, EMBLEM, SLIPCASE, SLIPCOVER and LEMUR): if the difference in the log likelihood in two successive EM iteration is smaller than <code>epsilon_em_fraction</code>*(-current log likelihood), then EM stops</p></li>
<li><p><code>iter</code> (values: integer, defualt value: 1, valid for EMBLEM, SLIPCASE, SLIPCOVER and LEMUR): maximum number of iteration of EM parameter learning. If set to -1, no maximum number of iterations is imposed</p></li>
<li><p><code>iterREF</code> (values: integer, defualt value: 1, valid for SLIPCASE, SLIPCOVER and LEMUR): maximum number of iteration of EM parameter learning for refinements. If set to -1, no maximum number of iterations is imposed.</p></li>
<li><p><code>random_restarts_number</code> (values: integer, default value: 1, valid for CEM, EMBLEM, SLIPCASE, SLIPCOVER and LEMUR): number of random restarts of EM learning</p></li>
<li><p><code>random_restarts_REFnumber</code> (values: integer, default value: 1, valid for SLIPCASE, SLIPCOVER and LEMUR): number of random restarts of EM learning for refinements</p></li>
<li><p><code>setrand</code> (values: rand(integer,integer,integer)): seed for the random functions, see Yap manual for allowed values</p></li>
<li><p><code>minimal_step</code> (values: [0,1], default value: 0.005, valid for RIB): minimal increment of <span class="math inline"><em>γ</em></span></p></li>
<li><p><code>maximal_step</code> (values: [0,1], default value: 0.1, valid for RIB): maximal increment of <span class="math inline"><em>γ</em></span></p></li>
<li><p><code>logsize_fraction</code> (values: [0,1], default value 0.9, valid for RIB): RIB stops when <span class="math inline"><strong>I</strong>(<em>C</em><em>H</em>, <em>T</em>; <em>Y</em>)</span> is above <code>logsize_fraction</code> times its maximum value (<span class="math inline">log|<em>C</em><em>H</em>, <em>T</em>|</span>, see <span class="citation">[12]</span>)</p></li>
<li><p><code>delta</code> (values: negative integer, default value -10, valid for RIB): value assigned to <span class="math inline">log0</span></p></li>
<li><p><code>epsilon_fraction</code> (values: integer, default value 100, valid for RIB): in the computation of the step, the value of <span class="math inline"><em>ϵ</em></span> of <span class="citation">[12]</span> is obtained as <span class="math inline">log|<em>C</em><em>H</em>, <em>T</em>|×</span><code>epsilon_fraction</code></p></li>
<li><p><code>max_rules</code> (values: integer, default value: 6000, valid for RIB and SLIPCASE): maximum number of ground rules. Used to set the size of arrays for storing internal statistics. Can be increased as much as memory allows.</p></li>
<li><p><code>logzero</code> (values: negative real, default value <span class="math inline">log(0.000001)</span>, valid for SLIPCASE, SLIPCOVER and LEMUR): value assigned to <span class="math inline">log0</span></p></li>
<li><p><code>examples</code> (values: <code>atoms</code>,<code>interpretations</code>, default value <code>atoms</code>, valid for SLIPCASE): determines how BDDs are built: if set to <code>interpretations</code>, a BDD for the conjunction of all the atoms for the target predicates in each interpretations is built. If set to <code>atoms</code>, a BDD is built for the conjunction of a group of atoms for the target predicates in each interpretations. The number of atoms in each group is determined by the parameter <code>group</code></p></li>
<li><p><code>group</code> (values: integer, default value: 1, valid for SLIPCASE): number of target atoms in the groups that are used to build BDDs</p></li>
<li><p><code>nax_iter</code> (values: integer, default value: 10, valid for SLIPCASE and SLIPCOVER): number of interations of beam search</p></li>
<li><p><code>max_var</code> (values: integer, default value: 1, valid for SLIPCASE, SLIPCOVER and LEMUR): maximum number of distinct variables in a clause</p></li>
<li><p><code>verbosity</code> (values: integer in [1,3], default value: 1): level of verbosity of the algorithms</p></li>
<li><p><code>beamsize</code> (values: integer, default value: 20, valid for SLIPCASE and SLIPCOVER): size of the beam</p></li>
<li><p><code>mcts_beamsize</code> (values: integer, default value: 3, valid for LEMUR): size of the MCTS beam</p></li>
<li><p><code>mcts_visits</code> (values: integer, default value: +inf, valid for LEMUR): maximum number of visits (Nicola controlla)</p></li>
<li><p><code>megaex_bottom</code> (values: integer, default value: 1, valid for SLIPCOVER): number of mega-examples on which to build the bottom clauses</p></li>
<li><p><code>initial_clauses_per_megaex</code> (values: integer, default value: 1, valid for SLIPCOVER): number of bottom clauses to build for each mega-example</p></li>
<li><p><code>d</code> (values: integer, default value: 10000, valid for SLIPCOVER): number of saturation steps when building the bottom clause</p></li>
<li><p><code>max_iter_structure</code> (values: integer, default value: 1, valid for SLIPCOVER): maximum number of theory search iterations</p></li>
<li><p><code>background_clauses</code> (values: integer, default value: 50, valid for SLIPCOVER): maximum numbers of background clauses</p></li>
<li><p><code>maxdepth_var</code> (values: integer, default value: 2, valid for SLIPCOVER and LEMUR): maximum depth of variables in clauses (as defined in <span class="citation">[10]</span>).</p></li>
<li><p><code>score</code> (values: <code>ll</code>, <code>aucpr</code>, default value <code>ll</code>, valid for SLIPCOVER): determines the score function for refinement: if set to <code>ll</code>, log likelihood is used, if set to <code>aucpr</code>, the area under the Precision-Recall curve is used.</p></li>
</ul>
<h2 id="commands-1">Commands</h2>
<p>To execute CEM, load <code>em.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/em&#39;)).</code></pre>
<p>and call:</p>
<pre><code>?:- em(stem).</code></pre>
<p>To execute RIB, load <code>rib.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/rib&#39;)).</code></pre>
<p>and call:</p>
<pre><code>?:- ib_par(stem).</code></pre>
<p>To execute EMBLEM, load <code>slipcase.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/slipcase&#39;)).</code></pre>
<p>and call</p>
<pre><code>?:- em(stem).</code></pre>
<p>To execute SLIPCASE, load <code>slipcase.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/slipcase&#39;)).</code></pre>
<p>and call</p>
<pre><code>?:- sl(stem).</code></pre>
<p>To execute SLIPCOVER, load <code>slipcover.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/slipcover&#39;)).</code></pre>
<p>and call</p>
<pre><code>?:- sl(stem).</code></pre>
<p>To execute LEMUR, load <code>lemur.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/lemur&#39;)).</code></pre>
<p>and call</p>
<pre><code>?:- &quot;mcts(stem,depth,c,iter,rules,covering)</code></pre>
<p>where <code>depth</code> (integer) is the maximum number of random specialization steps in the default policy, <code>C</code> (real) is the value of the MCTS <span class="math inline"><em>C</em></span> constant, <code>iter</code> (integer) is the number of UCT rounds, <code>rules</code> (integer) is the maximum number of clauses to be learned and <code>covering</code> (Boolean) dentoes whether the search is peformed in the space of clauses (true) or theories (false) (Nicola controlla).</p>
<h2 id="testing">Testing</h2>
<p>To test the theories learned, load <code>test.pl</code> with</p>
<pre><code>?:- use_module(library(&#39;cplint/test&#39;)).</code></pre>
<p>and call</p>
<pre><code>?:- main([&lt;stem_fold1&gt;,...,&lt;stem_foldn&gt;],[&lt;testing_set_fold1&gt;,...,
  &lt;testing_set_foldn&gt;]).</code></pre>
<p>For example, if you want to test the theory in <code>ai_train.rules</code> on the set <code>ai.kb</code>, you can call</p>
<pre><code>?:- main([ai_train],[ai]).</code></pre>
<p>The testing program has the following parameter:</p>
<ul>
<li><p><code>neg_ex</code> (values: <code>given</code>, <code>cw</code>, default value: <code>cw</code>): if set to <code>given</code>, the negative examples are taken from <code>&lt;testing_set_foldi&gt;.kb</code>, i.e., those example <code>ex</code> stored as <code>neg(ex)</code>; if set to <code>cw</code>, the negative examples are generated according to the closed world assumption, i.e., all atoms for target predicates that are not positive examples. The set of all atoms is obtained by collecting the set of constants for each type of the arguments of the target predicate.</p></li>
</ul>
<p>The testing program produces the following output in the current folder:</p>
<ul>
<li><p><code>cll.pl</code>: for each fold, the list of examples orderd by their probability of being true</p></li>
<li><p><code>areas.csv</code>: the areas under the Precision-Recall curve and the Receiver Operating Characteristic curve</p></li>
<li><p><code>curve_roc.m</code>: a Matlab file for plotting the Receiver Operating Characteristic curve</p></li>
<li><p><code>curve_pr.m</code>: a Matlab file for plotting the Precision-Recall curve</p></li>
</ul>
<h2 id="learning-examples">Learning Examples</h2>
<p>The subfolders <code>em</code>, <code>rib</code>, <code>slipcase</code> and <code>slipcover</code> of the <code>packages/cplint</code> folder in Yap git distribution contain examples of input and output files for the learning algorithms.</p>
<h1 id="license">License</h1>
<p><code>cplint</code>, as Yap, follows the Artistic License 2.0 that you can find in Yap CVS root dir. The copyright is by Fabrizio Riguzzi.</p>
<p>The modules in the approx subdirectory use SimplecuddLPADs, a modification of the <a href="http://dtai.cs.kuleuven.be/problog/download.html">Simplecudd</a> library whose copyright is by Katholieke Universiteit Leuven and that follows the Artistic License 2.0.</p>
<p>Some modules use the library <a href="http://vlsi.colorado.edu/\string ~fabio/">CUDD</a> for manipulating BDDs that is included in glu. For the use of CUDD, the following license must be accepted:</p>
<p>Copyright (c) 1995-2004, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li><p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p></li>
<li><p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p></li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS<br />
AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAU-SED<br />
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p><code>lpad.pl</code>, <code>semlpad.pl</code> and <code>cpl.pl</code> are based on the SLG system by Weidong Chen and <a href="http://www.cs.sunysb.edu/\string ~warren/">David Scott Warren</a>, Copyright (C) 1993 Southern Methodist University, 1993 SUNY at Stony Brook, see the file COYPRIGHT_SLG for detailed information on this copyright.</p>
<div id="refs" class="references">
<div id="ref-DBLP:journals/ngc/AptB91">
<p>1. K. R. Apt and M. Bezem. 1991. Acyclic programs. <em>New Gener. Comput.</em> 9, 3/4: 335–364.</p>
</div>
<div id="ref-BelRig11-CILC11-NC">
<p>2. Elena Bellodi and Fabrizio Riguzzi. 2011. EM over binary decision diagrams for probabilistic logic programs. <em>Proceedings of the 26th italian conference on computational logic (CILC2011), pescara, italy, 31 august 31-2 september, 2011</em>. Retrieved from <a href="http://www.ing.unife.it/docenti/FabrizioRiguzzi/Papers/BelRig-CILC11.pdf" class="uri">http://www.ing.unife.it/docenti/FabrizioRiguzzi/Papers/BelRig-CILC11.pdf</a></p>
</div>
<div id="ref-BelRig11-TR">
<p>3. Elena Bellodi and Fabrizio Riguzzi. 2011. <em>EM over binary decision diagrams for probabilistic logic programs</em>. Dipartimento di Ingegneria, Università di Ferrara, Italy. Retrieved from <a href="http://www.unife.it/dipartimento/ingegneria/informazione/informatica/rapporti-tecnici-1/CS-2011-01.pdf/view" class="uri">http://www.unife.it/dipartimento/ingegneria/informazione/informatica/rapporti-tecnici-1/CS-2011-01.pdf/view</a></p>
</div>
<div id="ref-BelRig11-ILP11-IC">
<p>4. Elena Bellodi and Fabrizio Riguzzi. 2011. Learning the structure of probabilistic logic programs. <em>Inductive logic programming, 21th international conference, iLP 2011, london, uK, 31 july-3 august, 2011</em>. Retrieved from <a href="http://ilp11.doc.ic.ac.uk/short_papers/ilp2011_submission_52.pdf" class="uri">http://ilp11.doc.ic.ac.uk/short_papers/ilp2011_submission_52.pdf</a></p>
</div>
<div id="ref-BelRig11-IDA">
<p>5. Elena Bellodi and Fabrizio Riguzzi. 2012. Expectation Maximization over binary decision diagrams for probabilistic logic programs. <em>Intel. Data Anal.</em> 16, 6.</p>
</div>
<div id="ref-BelRig13-TPLP-IJ">
<p>6. Elena Bellodi and Fabrizio Riguzzi. 2013. Structure learning of probabilistic logic programs by searching the clause space. <em>Theory and Practice of Logic Programming</em>.</p>
</div>
<div id="ref-Blo04-ILP04WIP-IC">
<p>7. H. Blockeel. 2004. Probabilistic logical models for mendel’s experiments: An exercise. <em>Inductive logic programming (ILP 2004), work in progress track</em>.</p>
</div>
<div id="ref-BraRig10-ILP10-IC">
<p>8. Stefano Bragaglia and Fabrizio Riguzzi. 2011. Approximate inference for logic programs with annotated disjunctions. <em>Inductive logic programming 20th international conference, iLP 2010, florence, italy, june 27-30, 2010. revised papers</em>, Springer, 30–37. <a href="http://doi.org/10.1007/978-3-642-21295-6_7" class="uri">http://doi.org/10.1007/978-3-642-21295-6_7</a></p>
</div>
<div id="ref-DBLP:journals/jacm/ChenW96">
<p>9. Weidong Chen and David Scott Warren. 1996. Tabled evaluation with delaying for general logic programs. <em>jacm</em> 43, 1: 20–74.</p>
</div>
<div id="ref-DBLP:journals/ai/Cohen95">
<p>10. William W. Cohen. 1995. Pac-learning non-recursive prolog clauses. <em>Artif. Intell.</em> 79, 1: 1–38.</p>
</div>
<div id="ref-DBLP:conf/ijcai/RaedtKT07">
<p>11. L. De Raedt, A. Kimmig, and H. Toivonen. 2007. ProbLog: A probabilistic Prolog and its application in link discovery. <em>International joint conference on artificial intelligence</em>, 2462–2467.</p>
</div>
<div id="ref-DBLP:journals/jmlr/ElidanF05">
<p>12. G. Elidan and N. Friedman. 2005. Learning hidden variable networks: The information bottleneck approach. <em>Journal of Machine Learning Research</em> 6: 81–127.</p>
</div>
<div id="ref-GetFri01-BC">
<p>13. L. Getoor, N. Friedman, D. Koller, and A. Pfeffer. 2001. Learning probabilistic relational models. In <em>Relational data mining</em>, Saso Dzeroski and Nada Lavrac (eds.). Springer-Verlag, Berlin.</p>
</div>
<div id="ref-Getoor+al:JMLR02">
<p>14. L. Getoor, N. Friedman, D. Koller, and B. Taskar. 2002. Learning probabilistic models of relational structure. <em>Journal of Machine Learning Research</em> 3: 679–707.</p>
</div>
<div id="ref-DBLP:journals/ai/Poole97">
<p>15. David Poole. 1997. The independent choice logic for modelling multiple agents under uncertainty. <em>Artificial Intelligence</em> 94, 1-2: 7–56.</p>
</div>
<div id="ref-RigDiM11-ML-IJ">
<p>16. Fabrizio Riguzzi and Nicola Di Mauro. 2011. Applying the information bottleneck to statistical relational learning. <em>Machine Learning</em>. <a href="http://doi.org/10.1007/s10994-011-5247-6" class="uri">http://doi.org/10.1007/s10994-011-5247-6</a></p>
</div>
<div id="ref-Rig-AIIA07-IC">
<p>17. Fabrizio Riguzzi. 2007. A top down interpreter for LPAD and CP-logic. <em>Congress of the italian association for artificial intelligence</em>, Springer, 109–120. <a href="http://doi.org/10.1007/978-3-540-74782-6\string_11 " class="uri">http://doi.org/10.1007/978-3-540-74782-6\string_11 </a></p>
</div>
<div id="ref-Rig-RCRA07-IC">
<p>18. Fabrizio Riguzzi. 2007. A top down interpreter for LPAD and CP-logic. <em>Proceedings of the 14th rCRA workshop experimental evaluation of algorithms for solving problems with combinatorial explosion</em>.</p>
</div>
<div id="ref-Rig09-LJIGPL-IJ">
<p>19. Fabrizio Riguzzi. 2009. Extended semantics and inference for the Independent Choice Logic. <em>Logic Journal of the IGPL</em> 17, 6: 589–629. <a href="http://doi.org/10.1093/jigpal/jzp025" class="uri">http://doi.org/10.1093/jigpal/jzp025</a></p>
</div>
<div id="ref-Rig11-CILC11-NC">
<p>20. Fabrizio Riguzzi. 2011. MCINTYRE: A Monte Carlo algorithm for probabilistic logic programming. <em>Proceedings of the 26th italian conference on computational logic (CILC2011), pescara, italy, 31 august-2 september, 2011</em>. Retrieved from <a href="http://www.ing.unife.it/docenti/FabrizioRiguzzi/Papers/Rig-CILC11.pdf" class="uri">http://www.ing.unife.it/docenti/FabrizioRiguzzi/Papers/Rig-CILC11.pdf</a></p>
</div>
<div id="ref-SanPagQaz03-UAI-IC">
<p>21. V. Santos Costa, D. Page, M. Qazi, and J. Cussens. 2003. CLP(<span class="math inline">ℬ𝒩</span>): Constraint logic programming for probabilistic knowledge. <em>Uncertainty in artificial intelligence</em>, Morgan Kaufmann.</p>
</div>
<div id="ref-VenVer03-TR">
<p>22. J. Vennekens and S. Verbaeten. 2003. <em>Logic programs with annotated disjunctions</em>. K. U. Leuven. Retrieved from <a href="http://www.cs.kuleuven.ac.be/\string~joost/techrep.ps" class="uri">http://www.cs.kuleuven.ac.be/\string~joost/techrep.ps</a></p>
</div>
<div id="ref-VenDenBru-JELIA06">
<p>23. J. Vennekens, M. Denecker, and M. Bruynooghe. 2006. Representing causal information about a probabilistic process. <em>Proceedings of the 10th european conference on logics in artificial intelligence</em>, Springer.</p>
</div>
<div id="ref-DBLP:journals/tplp/VennekensDB09">
<p>24. J. Vennekens, Marc Denecker, and Maurice Bruynooghe. 2009. CP-logic: A language of causal probabilistic events and its relation to logic programming. <em>Theory Pract. Log. Program.</em> 9, 3: 245–308.</p>
</div>
<div id="ref-VenVer04-ICLP04-IC">
<p>25. J. Vennekens, S. Verbaeten, and M. Bruynooghe. 2004. Logic programs with annotated disjunctions. <em>International conference on logic programming</em>, Springer, 195–209.</p>
</div>
</div>
</body>
</html>
